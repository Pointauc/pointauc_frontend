// This file is auto-generated by @hey-api/openapi-ts

import { type Options, appControllerGetHello, userControllerGetUser, userControllerValidateIntegration, userControllerSetAucSettings, daControllerSubscribe, daControllerAuthorize, daControllerRevoke, tourniquetControllerAuthorize, tourniquetControllerRevoke, tourniquetControllerWebhook, twitchControllerAuthorize, twitchControllerDeleteRewards, twitchControllerUpdateRedemption, twitchControllerUpdateRedemptions, twitchControllerUpdatePresets, twitchControllerRevoke, donatePayRuControllerAuthorize, donatePayRuControllerRevoke, donatePayEuControllerAuthorize, donatePayEuControllerRevoke, ihaqControllerAuthorize, ihaqControllerRevoke, randomControllerGetRandomInteger, signedRandomControllerCreateTicket, signedRandomControllerGetActiveTicket, signedRandomControllerGenerateWinner, signedRandomControllerGetWinnerRecordByTicket, signedRandomControllerGetRevealedTickets, broadcastingControllerBroadcastLots, broadcastingControllerBroadcastTimer, broadcastingControllerBroadcastWheel, broadcastingControllerBroadcastRules, authControllerRevokeRoleToken, authControllerGetRoleToken, authControllerRefreshRoleToken, authControllerRevokeAllCustomTokens, authControllerCreateCustomToken, authControllerListTokens, authControllerRevokeCustomToken, authControllerGetTokenInfo, overlaysControllerList, overlaysControllerCreate, overlaysControllerRemove, overlaysControllerGet, overlaysControllerUpdate, overlaysControllerReplace } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { AppControllerGetHelloData, UserControllerGetUserData, UserControllerValidateIntegrationData, UserControllerSetAucSettingsData, DaControllerSubscribeData, DaControllerAuthorizeData, DaControllerRevokeData, TourniquetControllerAuthorizeData, TourniquetControllerRevokeData, TourniquetControllerWebhookData, TwitchControllerAuthorizeData, TwitchControllerDeleteRewardsData, TwitchControllerUpdateRedemptionData, TwitchControllerUpdateRedemptionsData, TwitchControllerUpdatePresetsData, TwitchControllerRevokeData, DonatePayRuControllerAuthorizeData, DonatePayRuControllerAuthorizeResponse, DonatePayRuControllerRevokeData, DonatePayEuControllerAuthorizeData, DonatePayEuControllerAuthorizeResponse, DonatePayEuControllerRevokeData, IhaqControllerAuthorizeData, IhaqControllerAuthorizeResponse, IhaqControllerRevokeData, RandomControllerGetRandomIntegerData, SignedRandomControllerCreateTicketData, SignedRandomControllerCreateTicketError, SignedRandomControllerCreateTicketResponse, SignedRandomControllerGetActiveTicketData, SignedRandomControllerGenerateWinnerData, SignedRandomControllerGenerateWinnerError, SignedRandomControllerGenerateWinnerResponse, SignedRandomControllerGetWinnerRecordByTicketData, SignedRandomControllerGetRevealedTicketsData, SignedRandomControllerGetRevealedTicketsResponse, BroadcastingControllerBroadcastLotsData, BroadcastingControllerBroadcastTimerData, BroadcastingControllerBroadcastWheelData, BroadcastingControllerBroadcastRulesData, AuthControllerRevokeRoleTokenData, AuthControllerRevokeRoleTokenResponse, AuthControllerGetRoleTokenData, AuthControllerRefreshRoleTokenData, AuthControllerRefreshRoleTokenResponse, AuthControllerRevokeAllCustomTokensData, AuthControllerRevokeAllCustomTokensResponse, AuthControllerCreateCustomTokenData, AuthControllerCreateCustomTokenResponse, AuthControllerListTokensData, AuthControllerRevokeCustomTokenData, AuthControllerRevokeCustomTokenResponse, AuthControllerGetTokenInfoData, OverlaysControllerListData, OverlaysControllerCreateData, OverlaysControllerCreateResponse, OverlaysControllerRemoveData, OverlaysControllerRemoveResponse, OverlaysControllerGetData, OverlaysControllerUpdateData, OverlaysControllerUpdateResponse, OverlaysControllerReplaceData, OverlaysControllerReplaceResponse } from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? _heyApiClient).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const appControllerGetHelloQueryKey = (options?: Options<AppControllerGetHelloData>) => createQueryKey('appControllerGetHello', options);

export const appControllerGetHelloOptions = (options?: Options<AppControllerGetHelloData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appControllerGetHello({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appControllerGetHelloQueryKey(options)
    });
};

export const userControllerGetUserQueryKey = (options?: Options<UserControllerGetUserData>) => createQueryKey('userControllerGetUser', options);

export const userControllerGetUserOptions = (options?: Options<UserControllerGetUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userControllerGetUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userControllerGetUserQueryKey(options)
    });
};

export const userControllerValidateIntegrationQueryKey = (options?: Options<UserControllerValidateIntegrationData>) => createQueryKey('userControllerValidateIntegration', options);

export const userControllerValidateIntegrationOptions = (options?: Options<UserControllerValidateIntegrationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userControllerValidateIntegration({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userControllerValidateIntegrationQueryKey(options)
    });
};

export const userControllerSetAucSettingsMutation = (options?: Partial<Options<UserControllerSetAucSettingsData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UserControllerSetAucSettingsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UserControllerSetAucSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await userControllerSetAucSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const daControllerSubscribeQueryKey = (options?: Options<DaControllerSubscribeData>) => createQueryKey('daControllerSubscribe', options);

export const daControllerSubscribeOptions = (options?: Options<DaControllerSubscribeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await daControllerSubscribe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: daControllerSubscribeQueryKey(options)
    });
};

export const daControllerSubscribeMutation = (options?: Partial<Options<DaControllerSubscribeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerSubscribeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerSubscribeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await daControllerSubscribe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const daControllerAuthorizeQueryKey = (options?: Options<DaControllerAuthorizeData>) => createQueryKey('daControllerAuthorize', options);

export const daControllerAuthorizeOptions = (options?: Options<DaControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await daControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: daControllerAuthorizeQueryKey(options)
    });
};

export const daControllerAuthorizeMutation = (options?: Partial<Options<DaControllerAuthorizeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await daControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const daControllerRevokeQueryKey = (options?: Options<DaControllerRevokeData>) => createQueryKey('daControllerRevoke', options);

export const daControllerRevokeOptions = (options?: Options<DaControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await daControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: daControllerRevokeQueryKey(options)
    });
};

export const daControllerRevokeMutation = (options?: Partial<Options<DaControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DaControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await daControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tourniquetControllerAuthorizeQueryKey = (options?: Options<TourniquetControllerAuthorizeData>) => createQueryKey('tourniquetControllerAuthorize', options);

export const tourniquetControllerAuthorizeOptions = (options?: Options<TourniquetControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tourniquetControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tourniquetControllerAuthorizeQueryKey(options)
    });
};

export const tourniquetControllerAuthorizeMutation = (options?: Partial<Options<TourniquetControllerAuthorizeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await tourniquetControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tourniquetControllerRevokeQueryKey = (options?: Options<TourniquetControllerRevokeData>) => createQueryKey('tourniquetControllerRevoke', options);

export const tourniquetControllerRevokeOptions = (options?: Options<TourniquetControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tourniquetControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tourniquetControllerRevokeQueryKey(options)
    });
};

export const tourniquetControllerRevokeMutation = (options?: Partial<Options<TourniquetControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await tourniquetControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tourniquetControllerWebhookQueryKey = (options?: Options<TourniquetControllerWebhookData>) => createQueryKey('tourniquetControllerWebhook', options);

export const tourniquetControllerWebhookOptions = (options?: Options<TourniquetControllerWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tourniquetControllerWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tourniquetControllerWebhookQueryKey(options)
    });
};

export const tourniquetControllerWebhookMutation = (options?: Partial<Options<TourniquetControllerWebhookData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerWebhookData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TourniquetControllerWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await tourniquetControllerWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerAuthorizeQueryKey = (options?: Options<TwitchControllerAuthorizeData>) => createQueryKey('twitchControllerAuthorize', options);

export const twitchControllerAuthorizeOptions = (options?: Options<TwitchControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await twitchControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: twitchControllerAuthorizeQueryKey(options)
    });
};

export const twitchControllerAuthorizeMutation = (options?: Partial<Options<TwitchControllerAuthorizeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerDeleteRewardsMutation = (options?: Partial<Options<TwitchControllerDeleteRewardsData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerDeleteRewardsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerDeleteRewardsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerDeleteRewards({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerUpdateRedemptionMutation = (options?: Partial<Options<TwitchControllerUpdateRedemptionData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdateRedemptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdateRedemptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerUpdateRedemption({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerUpdateRedemptionsMutation = (options?: Partial<Options<TwitchControllerUpdateRedemptionsData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdateRedemptionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdateRedemptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerUpdateRedemptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerUpdatePresetsMutation = (options?: Partial<Options<TwitchControllerUpdatePresetsData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdatePresetsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerUpdatePresetsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerUpdatePresets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const twitchControllerRevokeQueryKey = (options?: Options<TwitchControllerRevokeData>) => createQueryKey('twitchControllerRevoke', options);

export const twitchControllerRevokeOptions = (options?: Options<TwitchControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await twitchControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: twitchControllerRevokeQueryKey(options)
    });
};

export const twitchControllerRevokeMutation = (options?: Partial<Options<TwitchControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TwitchControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await twitchControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const donatePayRuControllerAuthorizeQueryKey = (options: Options<DonatePayRuControllerAuthorizeData>) => createQueryKey('donatePayRuControllerAuthorize', options);

/**
 * Authorize user with DonatePay
 * Processes DonatePay access token and links the DonatePay account to the user session. Returns whether this is a new user registration.
 */
export const donatePayRuControllerAuthorizeOptions = (options: Options<DonatePayRuControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await donatePayRuControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: donatePayRuControllerAuthorizeQueryKey(options)
    });
};

/**
 * Authorize user with DonatePay
 * Processes DonatePay access token and links the DonatePay account to the user session. Returns whether this is a new user registration.
 */
export const donatePayRuControllerAuthorizeMutation = (options?: Partial<Options<DonatePayRuControllerAuthorizeData>>): UseMutationOptions<DonatePayRuControllerAuthorizeResponse, AxiosError<DefaultError>, Options<DonatePayRuControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<DonatePayRuControllerAuthorizeResponse, AxiosError<DefaultError>, Options<DonatePayRuControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await donatePayRuControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const donatePayRuControllerRevokeQueryKey = (options?: Options<DonatePayRuControllerRevokeData>) => createQueryKey('donatePayRuControllerRevoke', options);

/**
 * Revoke DonatePay integration
 * Invalidates and removes DonatePay integration for the authenticated user. Requires authentication via cookie.
 */
export const donatePayRuControllerRevokeOptions = (options?: Options<DonatePayRuControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await donatePayRuControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: donatePayRuControllerRevokeQueryKey(options)
    });
};

/**
 * Revoke DonatePay integration
 * Invalidates and removes DonatePay integration for the authenticated user. Requires authentication via cookie.
 */
export const donatePayRuControllerRevokeMutation = (options?: Partial<Options<DonatePayRuControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DonatePayRuControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DonatePayRuControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await donatePayRuControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const donatePayEuControllerAuthorizeQueryKey = (options: Options<DonatePayEuControllerAuthorizeData>) => createQueryKey('donatePayEuControllerAuthorize', options);

/**
 * Authorize user with DonatePay
 * Processes DonatePay access token and links the DonatePay account to the user session. Returns whether this is a new user registration.
 */
export const donatePayEuControllerAuthorizeOptions = (options: Options<DonatePayEuControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await donatePayEuControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: donatePayEuControllerAuthorizeQueryKey(options)
    });
};

/**
 * Authorize user with DonatePay
 * Processes DonatePay access token and links the DonatePay account to the user session. Returns whether this is a new user registration.
 */
export const donatePayEuControllerAuthorizeMutation = (options?: Partial<Options<DonatePayEuControllerAuthorizeData>>): UseMutationOptions<DonatePayEuControllerAuthorizeResponse, AxiosError<DefaultError>, Options<DonatePayEuControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<DonatePayEuControllerAuthorizeResponse, AxiosError<DefaultError>, Options<DonatePayEuControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await donatePayEuControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const donatePayEuControllerRevokeQueryKey = (options?: Options<DonatePayEuControllerRevokeData>) => createQueryKey('donatePayEuControllerRevoke', options);

/**
 * Revoke DonatePay integration
 * Invalidates and removes DonatePay integration for the authenticated user. Requires authentication via cookie.
 */
export const donatePayEuControllerRevokeOptions = (options?: Options<DonatePayEuControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await donatePayEuControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: donatePayEuControllerRevokeQueryKey(options)
    });
};

/**
 * Revoke DonatePay integration
 * Invalidates and removes DonatePay integration for the authenticated user. Requires authentication via cookie.
 */
export const donatePayEuControllerRevokeMutation = (options?: Partial<Options<DonatePayEuControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DonatePayEuControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DonatePayEuControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await donatePayEuControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ihaqControllerAuthorizeQueryKey = (options: Options<IhaqControllerAuthorizeData>) => createQueryKey('ihaqControllerAuthorize', options);

/**
 * Authorize user with IHAQ
 * Processes IHAQ OAuth authorization code and links the IHAQ account to the user session. Returns whether this is a new user registration.
 */
export const ihaqControllerAuthorizeOptions = (options: Options<IhaqControllerAuthorizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ihaqControllerAuthorize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ihaqControllerAuthorizeQueryKey(options)
    });
};

/**
 * Authorize user with IHAQ
 * Processes IHAQ OAuth authorization code and links the IHAQ account to the user session. Returns whether this is a new user registration.
 */
export const ihaqControllerAuthorizeMutation = (options?: Partial<Options<IhaqControllerAuthorizeData>>): UseMutationOptions<IhaqControllerAuthorizeResponse, AxiosError<DefaultError>, Options<IhaqControllerAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<IhaqControllerAuthorizeResponse, AxiosError<DefaultError>, Options<IhaqControllerAuthorizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ihaqControllerAuthorize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ihaqControllerRevokeQueryKey = (options?: Options<IhaqControllerRevokeData>) => createQueryKey('ihaqControllerRevoke', options);

/**
 * Revoke IHAQ integration
 * Invalidates and removes IHAQ integration for the authenticated user. Requires authentication via cookie.
 */
export const ihaqControllerRevokeOptions = (options?: Options<IhaqControllerRevokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ihaqControllerRevoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ihaqControllerRevokeQueryKey(options)
    });
};

/**
 * Revoke IHAQ integration
 * Invalidates and removes IHAQ integration for the authenticated user. Requires authentication via cookie.
 */
export const ihaqControllerRevokeMutation = (options?: Partial<Options<IhaqControllerRevokeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<IhaqControllerRevokeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<IhaqControllerRevokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ihaqControllerRevoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const randomControllerGetRandomIntegerQueryKey = (options: Options<RandomControllerGetRandomIntegerData>) => createQueryKey('randomControllerGetRandomInteger', options);

export const randomControllerGetRandomIntegerOptions = (options: Options<RandomControllerGetRandomIntegerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await randomControllerGetRandomInteger({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: randomControllerGetRandomIntegerQueryKey(options)
    });
};

export const signedRandomControllerCreateTicketQueryKey = (options?: Options<SignedRandomControllerCreateTicketData>) => createQueryKey('signedRandomControllerCreateTicket', options);

/**
 * Create a Random.org ticket
 * Creates a single unrevealed ticket for the authenticated user. Only one active ticket per user is allowed. Does not consume quota.
 */
export const signedRandomControllerCreateTicketOptions = (options?: Options<SignedRandomControllerCreateTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signedRandomControllerCreateTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerCreateTicketQueryKey(options)
    });
};

/**
 * Create a Random.org ticket
 * Creates a single unrevealed ticket for the authenticated user. Only one active ticket per user is allowed. Does not consume quota.
 */
export const signedRandomControllerCreateTicketMutation = (options?: Partial<Options<SignedRandomControllerCreateTicketData>>): UseMutationOptions<SignedRandomControllerCreateTicketResponse, AxiosError<SignedRandomControllerCreateTicketError>, Options<SignedRandomControllerCreateTicketData>> => {
    const mutationOptions: UseMutationOptions<SignedRandomControllerCreateTicketResponse, AxiosError<SignedRandomControllerCreateTicketError>, Options<SignedRandomControllerCreateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await signedRandomControllerCreateTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const signedRandomControllerGetActiveTicketQueryKey = (options?: Options<SignedRandomControllerGetActiveTicketData>) => createQueryKey('signedRandomControllerGetActiveTicket', options);

/**
 * Get active ticket
 * Returns the current unrevealed ticket for the authenticated user. Returns an object with all null values if no active ticket exists.
 */
export const signedRandomControllerGetActiveTicketOptions = (options?: Options<SignedRandomControllerGetActiveTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signedRandomControllerGetActiveTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerGetActiveTicketQueryKey(options)
    });
};

export const signedRandomControllerGenerateWinnerQueryKey = (options: Options<SignedRandomControllerGenerateWinnerData>) => createQueryKey('signedRandomControllerGenerateWinner', options);

/**
 * Generate winner seed
 * Generates a random decimal number using Random.org to determine the winner from participants. Consumes daily quota (6/day). Quota is only consumed if Random.org request succeeds. Uses currently active ticket.
 */
export const signedRandomControllerGenerateWinnerOptions = (options: Options<SignedRandomControllerGenerateWinnerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signedRandomControllerGenerateWinner({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerGenerateWinnerQueryKey(options)
    });
};

/**
 * Generate winner seed
 * Generates a random decimal number using Random.org to determine the winner from participants. Consumes daily quota (6/day). Quota is only consumed if Random.org request succeeds. Uses currently active ticket.
 */
export const signedRandomControllerGenerateWinnerMutation = (options?: Partial<Options<SignedRandomControllerGenerateWinnerData>>): UseMutationOptions<SignedRandomControllerGenerateWinnerResponse, AxiosError<SignedRandomControllerGenerateWinnerError>, Options<SignedRandomControllerGenerateWinnerData>> => {
    const mutationOptions: UseMutationOptions<SignedRandomControllerGenerateWinnerResponse, AxiosError<SignedRandomControllerGenerateWinnerError>, Options<SignedRandomControllerGenerateWinnerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await signedRandomControllerGenerateWinner({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const signedRandomControllerGetWinnerRecordByTicketQueryKey = (options: Options<SignedRandomControllerGetWinnerRecordByTicketData>) => createQueryKey('signedRandomControllerGetWinnerRecordByTicket', options);

/**
 * Get winner record by ticket ID
 * Public endpoint that returns the complete winner record for a specific ticket ID.
 */
export const signedRandomControllerGetWinnerRecordByTicketOptions = (options: Options<SignedRandomControllerGetWinnerRecordByTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signedRandomControllerGetWinnerRecordByTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerGetWinnerRecordByTicketQueryKey(options)
    });
};

export const signedRandomControllerGetRevealedTicketsQueryKey = (options: Options<SignedRandomControllerGetRevealedTicketsData>) => createQueryKey('signedRandomControllerGetRevealedTickets', options);

/**
 * Get revealed tickets for a user
 * Public endpoint that returns a paginated list of revealed tickets for a specific user. Returns only ticketId, metadata, and createdAt.
 */
export const signedRandomControllerGetRevealedTicketsOptions = (options: Options<SignedRandomControllerGetRevealedTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signedRandomControllerGetRevealedTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerGetRevealedTicketsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const signedRandomControllerGetRevealedTicketsInfiniteQueryKey = (options: Options<SignedRandomControllerGetRevealedTicketsData>): QueryKey<Options<SignedRandomControllerGetRevealedTicketsData>> => createQueryKey('signedRandomControllerGetRevealedTickets', options, true);

/**
 * Get revealed tickets for a user
 * Public endpoint that returns a paginated list of revealed tickets for a specific user. Returns only ticketId, metadata, and createdAt.
 */
export const signedRandomControllerGetRevealedTicketsInfiniteOptions = (options: Options<SignedRandomControllerGetRevealedTicketsData>) => {
    return infiniteQueryOptions<SignedRandomControllerGetRevealedTicketsResponse, AxiosError<DefaultError>, InfiniteData<SignedRandomControllerGetRevealedTicketsResponse>, QueryKey<Options<SignedRandomControllerGetRevealedTicketsData>>, number | Pick<QueryKey<Options<SignedRandomControllerGetRevealedTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SignedRandomControllerGetRevealedTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await signedRandomControllerGetRevealedTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signedRandomControllerGetRevealedTicketsInfiniteQueryKey(options)
    });
};

export const broadcastingControllerBroadcastLotsQueryKey = (options: Options<BroadcastingControllerBroadcastLotsData>) => createQueryKey('broadcastingControllerBroadcastLots', options);

export const broadcastingControllerBroadcastLotsOptions = (options: Options<BroadcastingControllerBroadcastLotsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await broadcastingControllerBroadcastLots({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: broadcastingControllerBroadcastLotsQueryKey(options)
    });
};

export const broadcastingControllerBroadcastLotsMutation = (options?: Partial<Options<BroadcastingControllerBroadcastLotsData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastLotsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastLotsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await broadcastingControllerBroadcastLots({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const broadcastingControllerBroadcastTimerQueryKey = (options: Options<BroadcastingControllerBroadcastTimerData>) => createQueryKey('broadcastingControllerBroadcastTimer', options);

export const broadcastingControllerBroadcastTimerOptions = (options: Options<BroadcastingControllerBroadcastTimerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await broadcastingControllerBroadcastTimer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: broadcastingControllerBroadcastTimerQueryKey(options)
    });
};

export const broadcastingControllerBroadcastTimerMutation = (options?: Partial<Options<BroadcastingControllerBroadcastTimerData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastTimerData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastTimerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await broadcastingControllerBroadcastTimer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const broadcastingControllerBroadcastWheelQueryKey = (options: Options<BroadcastingControllerBroadcastWheelData>) => createQueryKey('broadcastingControllerBroadcastWheel', options);

export const broadcastingControllerBroadcastWheelOptions = (options: Options<BroadcastingControllerBroadcastWheelData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await broadcastingControllerBroadcastWheel({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: broadcastingControllerBroadcastWheelQueryKey(options)
    });
};

export const broadcastingControllerBroadcastWheelMutation = (options?: Partial<Options<BroadcastingControllerBroadcastWheelData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastWheelData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastWheelData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await broadcastingControllerBroadcastWheel({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const broadcastingControllerBroadcastRulesQueryKey = (options: Options<BroadcastingControllerBroadcastRulesData>) => createQueryKey('broadcastingControllerBroadcastRules', options);

export const broadcastingControllerBroadcastRulesOptions = (options: Options<BroadcastingControllerBroadcastRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await broadcastingControllerBroadcastRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: broadcastingControllerBroadcastRulesQueryKey(options)
    });
};

export const broadcastingControllerBroadcastRulesMutation = (options?: Partial<Options<BroadcastingControllerBroadcastRulesData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastRulesData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<BroadcastingControllerBroadcastRulesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await broadcastingControllerBroadcastRules({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke role-based token
 */
export const authControllerRevokeRoleTokenMutation = (options?: Partial<Options<AuthControllerRevokeRoleTokenData>>): UseMutationOptions<AuthControllerRevokeRoleTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeRoleTokenData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerRevokeRoleTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeRoleTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerRevokeRoleToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerGetRoleTokenQueryKey = (options: Options<AuthControllerGetRoleTokenData>) => createQueryKey('authControllerGetRoleToken', options);

/**
 * Get or create role-based token
 */
export const authControllerGetRoleTokenOptions = (options: Options<AuthControllerGetRoleTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerGetRoleToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerGetRoleTokenQueryKey(options)
    });
};

export const authControllerRefreshRoleTokenQueryKey = (options: Options<AuthControllerRefreshRoleTokenData>) => createQueryKey('authControllerRefreshRoleToken', options);

/**
 * Refresh role-based token
 */
export const authControllerRefreshRoleTokenOptions = (options: Options<AuthControllerRefreshRoleTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerRefreshRoleToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerRefreshRoleTokenQueryKey(options)
    });
};

/**
 * Refresh role-based token
 */
export const authControllerRefreshRoleTokenMutation = (options?: Partial<Options<AuthControllerRefreshRoleTokenData>>): UseMutationOptions<AuthControllerRefreshRoleTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRefreshRoleTokenData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerRefreshRoleTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRefreshRoleTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerRefreshRoleToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke all custom tokens
 */
export const authControllerRevokeAllCustomTokensMutation = (options?: Partial<Options<AuthControllerRevokeAllCustomTokensData>>): UseMutationOptions<AuthControllerRevokeAllCustomTokensResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeAllCustomTokensData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerRevokeAllCustomTokensResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeAllCustomTokensData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerRevokeAllCustomTokens({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerCreateCustomTokenQueryKey = (options: Options<AuthControllerCreateCustomTokenData>) => createQueryKey('authControllerCreateCustomToken', options);

/**
 * Create custom token
 */
export const authControllerCreateCustomTokenOptions = (options: Options<AuthControllerCreateCustomTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerCreateCustomToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerCreateCustomTokenQueryKey(options)
    });
};

/**
 * Create custom token
 */
export const authControllerCreateCustomTokenMutation = (options?: Partial<Options<AuthControllerCreateCustomTokenData>>): UseMutationOptions<AuthControllerCreateCustomTokenResponse, AxiosError<DefaultError>, Options<AuthControllerCreateCustomTokenData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerCreateCustomTokenResponse, AxiosError<DefaultError>, Options<AuthControllerCreateCustomTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerCreateCustomToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerListTokensQueryKey = (options?: Options<AuthControllerListTokensData>) => createQueryKey('authControllerListTokens', options);

/**
 * List user tokens
 */
export const authControllerListTokensOptions = (options?: Options<AuthControllerListTokensData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerListTokens({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerListTokensQueryKey(options)
    });
};

/**
 * Revoke custom token
 */
export const authControllerRevokeCustomTokenMutation = (options?: Partial<Options<AuthControllerRevokeCustomTokenData>>): UseMutationOptions<AuthControllerRevokeCustomTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeCustomTokenData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerRevokeCustomTokenResponse, AxiosError<DefaultError>, Options<AuthControllerRevokeCustomTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerRevokeCustomToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerGetTokenInfoQueryKey = (options?: Options<AuthControllerGetTokenInfoData>) => createQueryKey('authControllerGetTokenInfo', options);

/**
 * Get current token information
 */
export const authControllerGetTokenInfoOptions = (options?: Options<AuthControllerGetTokenInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerGetTokenInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerGetTokenInfoQueryKey(options)
    });
};

export const overlaysControllerListQueryKey = (options?: Options<OverlaysControllerListData>) => createQueryKey('overlaysControllerList', options);

/**
 * List overlays
 */
export const overlaysControllerListOptions = (options?: Options<OverlaysControllerListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await overlaysControllerList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: overlaysControllerListQueryKey(options)
    });
};

export const overlaysControllerCreateQueryKey = (options: Options<OverlaysControllerCreateData>) => createQueryKey('overlaysControllerCreate', options);

/**
 * Create overlay
 */
export const overlaysControllerCreateOptions = (options: Options<OverlaysControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await overlaysControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: overlaysControllerCreateQueryKey(options)
    });
};

/**
 * Create overlay
 */
export const overlaysControllerCreateMutation = (options?: Partial<Options<OverlaysControllerCreateData>>): UseMutationOptions<OverlaysControllerCreateResponse, AxiosError<DefaultError>, Options<OverlaysControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<OverlaysControllerCreateResponse, AxiosError<DefaultError>, Options<OverlaysControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await overlaysControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete overlay
 */
export const overlaysControllerRemoveMutation = (options?: Partial<Options<OverlaysControllerRemoveData>>): UseMutationOptions<OverlaysControllerRemoveResponse, AxiosError<DefaultError>, Options<OverlaysControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<OverlaysControllerRemoveResponse, AxiosError<DefaultError>, Options<OverlaysControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await overlaysControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const overlaysControllerGetQueryKey = (options: Options<OverlaysControllerGetData>) => createQueryKey('overlaysControllerGet', options);

/**
 * Get overlay by ID
 */
export const overlaysControllerGetOptions = (options: Options<OverlaysControllerGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await overlaysControllerGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: overlaysControllerGetQueryKey(options)
    });
};

/**
 * Update overlay (partial)
 */
export const overlaysControllerUpdateMutation = (options?: Partial<Options<OverlaysControllerUpdateData>>): UseMutationOptions<OverlaysControllerUpdateResponse, AxiosError<DefaultError>, Options<OverlaysControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<OverlaysControllerUpdateResponse, AxiosError<DefaultError>, Options<OverlaysControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await overlaysControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Replace overlay (full)
 */
export const overlaysControllerReplaceMutation = (options?: Partial<Options<OverlaysControllerReplaceData>>): UseMutationOptions<OverlaysControllerReplaceResponse, AxiosError<DefaultError>, Options<OverlaysControllerReplaceData>> => {
    const mutationOptions: UseMutationOptions<OverlaysControllerReplaceResponse, AxiosError<DefaultError>, Options<OverlaysControllerReplaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await overlaysControllerReplace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};